/*! For license information please see index.js.LICENSE.txt */

!function (e, t) { if ("object" == typeof exports && "object" == typeof module) module.exports = t(require("blockly/core")); else if ("function" == typeof define && define.amd) define(["blockly/core"], t); else { var n = "object" == typeof exports ? t(require("blockly/core")) : t(e.Blockly); for (var o in n) ("object" == typeof exports ? exports : e)[o] = n[o] } }(this, (e => (() => { "use strict"; var t = { 370: t => { t.exports = e } }, n = {}; function o(e) { var r = n[e]; if (void 0 !== r) return r.exports; var i = n[e] = { exports: {} }; return t[e](i, i.exports, o), i.exports } o.d = (e, t) => { for (var n in t) o.o(t, n) && !o.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, o.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), o.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }; var r = {}; o.r(r), o.d(r, { BlockShadowStateChange: () => s, shadowBlockConversionChangeListener: () => a }); var i = o(370); class s extends i.Events.BlockBase { constructor(e, t, n) { super(e), this.type = s.EVENT_TYPE, this.inputIndexInParent = t, this.shadowState = n } toJson() { const e = super.toJson(); return e.inputIndexInParent = this.inputIndexInParent, e.shadowState = this.shadowState, e } static fromJson(e, t, n) { const o = super.fromJson(e, t, n); return o.inputIndexInParent = e.inputIndexInParent, o.shadowState = e.shadowState, n } isNull() { return !1 } run(e) { const t = this.getEventWorkspace_(); if (!this.blockId) throw new Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson"); const n = t.getBlockById(this.blockId); if (!n) throw new Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson"); const o = n.getConnections_(!0); let r; if (null === this.inputIndexInParent) r = n.nextConnection; else { if ("number" != typeof this.inputIndexInParent || this.inputIndexInParent < 0 || this.inputIndexInParent >= o.length) throw new Error("inputIndexInParent was invalid."); r = n.inputList[this.inputIndexInParent].connection } if (null === r) throw new Error("No matching connection was found."); e && r.setShadowState(this.shadowState || null) } } function c(e) { var t, n; let o = null, r = !1; if ((null === (t = e.previousConnection) || void 0 === t ? void 0 : t.isConnected()) ? o = e.previousConnection.targetConnection : (null === (n = e.outputConnection) || void 0 === n ? void 0 : n.isConnected()) && (o = e.outputConnection.targetConnection, r = !0), null === o) return e; let a = o.getSourceBlock(); const l = o.getParentInput(), u = l ? a.inputList.indexOf(l) : null, d = o.getShadowState(!1), p = i.serialization.blocks.save(e, { addCoordinates: !1, addInputBlocks: !0, addNextBlocks: !0, doFullSerialization: !1 }); if (null === d || null === p) return e; if (a.isShadow()) { const e = c(a); if (null === e) throw new Error("No parent block was created, so we can't recreate the current block either."); if (a = e, null === u) o = a.nextConnection; else { if (u < 0 || u >= a.inputList.length) throw new Error("inputIndexInParent is invalid."); o = a.inputList[u].connection } if (null === o) throw new Error("Couldn't find the corresponding connection on the new version of the parent block.") } p.id = void 0; const h = i.serialization.blocks.append(p, a.workspace, { recordUndo: !0 }), f = r ? h.outputConnection : h.previousConnection; f && o.connect(f); const w = i.common.getSelected() === e; return o.setShadowState(d), i.Events.fire(new s(a, u, d)), w && i.common.setSelected(h), h } function a(e) { if (!e.recordUndo) return; if (e.type != i.Events.BLOCK_CHANGE) return; const t = e; if (!t.workspaceId || !t.blockId) return; const n = i.Workspace.getById(t.workspaceId); if (!n) return; const o = n.getBlockById(t.blockId); if (!o) return; if (!o.isShadow()) return; const r = i.Events.getGroup(); t.group ? i.Events.setGroup(t.group) : i.Events.setGroup(!0), c(o), i.Events.setGroup(r) } return s.EVENT_TYPE = "block_shadow_state_change", i.registry.register(i.registry.Type.EVENT, s.EVENT_TYPE, s), r })()));