/*! For license information please see index.js.LICENSE.txt */

!function (e, t) { if ("object" == typeof exports && "object" == typeof module) module.exports = t(require("blockly/core")); else if ("function" == typeof define && define.amd) define(["blockly/core"], t); else { var n = "object" == typeof exports ? t(require("blockly/core")) : t(e.Blockly); for (var o in n) ("object" == typeof exports ? exports : e)[o] = n[o] } }(this, (e => (() => { "use strict"; var t = { 370: t => { t.exports = e } }, n = {}; function o(e) { var i = n[e]; if (void 0 !== i) return i.exports; var s = n[e] = { exports: {} }; return t[e](s, s.exports, o), s.exports } o.d = (e, t) => { for (var n in t) o.o(t, n) && !o.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, o.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), o.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }; var i = {}; o.r(i), o.d(i, { FieldDependentDropdown: () => l }); var s = o(370); function r(e, t) { return e.length === t.length && e.every(((e, n) => { const o = t[n]; return Array.isArray(e) && Array.isArray(o) ? r(e, o) : e === o })) } class a extends s.Events.BlockBase { constructor(e, t, n, o, i, s) { super(e), this.type = a.EVENT_TYPE, e && t && n && o && i && s && (this.name = t, this.oldValue = n, this.newValue = o, this.oldOptions = i, this.newOptions = s) } toJson() { const e = super.toJson(); if (!(this.name && this.oldValue && this.newValue && this.oldOptions && this.newOptions)) throw new Error("The changed element is undefined. Either pass all needed parameters to the constructor, or call fromJson."); return e.name = this.name, e.oldValue = this.oldValue, e.newValue = this.newValue, e.oldOptions = this.oldOptions, e.newOptions = this.newOptions, e } static fromJson(e, t, n) { const o = super.fromJson(e, t, n); return o.name = e.name, o.oldValue = e.oldValue, o.newValue = e.newValue, o.oldOptions = e.oldOptions, o.newOptions = e.newOptions, o } isNull() { const e = this.oldValue === this.newValue, t = this.oldOptions === this.newOptions || Array.isArray(this.oldOptions) && Array.isArray(this.newOptions) && r(this.oldOptions, this.newOptions); return e && t } run(e) { if (!(this.blockId && this.name && this.oldValue && this.newValue && this.oldOptions && this.newOptions)) return void console.warn("Can't run uninitialized event."); const t = this.getEventWorkspace_().getBlockById(this.blockId); if (!t) return void console.warn("Can't change non-existent block: " + this.blockId); const n = t.getField(this.name); if (!n) return void console.warn("Can't change non-existent dropdown field: " + this.name); const o = e ? this.newValue : this.oldValue, i = e ? this.newOptions : this.oldOptions; n.dependencyData.derivedOptions = i, n.getOptions(!1), n.setValue(o) } } a.EVENT_TYPE = "dropdown_options_change", s.registry.register(s.registry.Type.EVENT, a.EVENT_TYPE, a); class l extends s.FieldDropdown { constructor(e, t, n, o, i) { const s = {}; super((() => { if (s.derivedOptions) return s.derivedOptions; if (s.parentField) { const e = s.parentField.getValue(); if (e) { const n = t[e]; if (n) return n } } return n || [["", ""]] }), o, i), this.parentName = e, this.optionMapping = t, this.defaultOptions = n, this.dependencyData = s } static fromJson(e) { return new l(e.parentName, e.optionMapping, e.defaultOptions, void 0, e) } setSourceBlock(e) { var t; super.setSourceBlock(e); const n = e.getField(this.parentName); if (!n) throw new Error("Could not find a parent field with the name " + this.parentName + " for the dependent dropdown."); this.dependencyData.parentField = n; const o = n.getValidator(); n.setValidator((e => { if (o) { const t = o(e); if (null === t) return null; void 0 !== t && (e = t) } return this.updateOptionsBasedOnNewValue(e), e })), this.updateOptionsBasedOnNewValue(null !== (t = n.getValue()) && void 0 !== t ? t : void 0) } updateOptionsBasedOnNewValue(e) { if (null == e) return; const t = this.getSourceBlock(); if (!t) throw new Error("Could not validate a field that is not attached to a block: " + this.name); const n = this.getValue(), o = this.getOptions(!1); let i = this.optionMapping[e]; if (!i) { if (!this.defaultOptions) return void console.warn("Could not find child options for the parent value: " + e); i = this.defaultOptions } const r = null != i.find((e => e[1] == n)) ? n : i[0][1]; this.dependencyData.derivedOptions = i, this.getOptions(!1), s.Events.disable(), this.setValue(r), s.Events.enable(), s.Events.getRecordUndo() && (s.Events.getGroup() || (s.Events.setGroup(!0), setTimeout((() => s.Events.setGroup(!1)))), s.Events.fire(new a(t, this.name, null != n ? n : void 0, null != r ? r : void 0, o, i))) } } return s.fieldRegistry.register("field_dependent_dropdown", l), i })()));