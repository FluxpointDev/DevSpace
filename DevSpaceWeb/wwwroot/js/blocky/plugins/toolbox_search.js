/*! For license information please see index.js.LICENSE.txt */

!function (e, t) { if ("object" == typeof exports && "object" == typeof module) module.exports = t(require("blockly/core")); else if ("function" == typeof define && define.amd) define(["blockly/core"], t); else { var r = "object" == typeof exports ? t(require("blockly/core")) : t(e.Blockly); for (var s in r) ("object" == typeof exports ? exports : e)[s] = r[s] } }(this, (e => (() => { "use strict"; var t = { 370: t => { t.exports = e } }, r = {}, s = function e(s) { var o = r[s]; if (void 0 !== o) return o.exports; var i = r[s] = { exports: {} }; return t[s](i, i.exports, e), i.exports }(370); class o { constructor() { this.blockCreationWorkspace = new s.Workspace, this.trigramsToBlocks = new Map } indexBlocks(e) { const t = new s.Workspace; e.forEach((e => { const r = t.newBlock(e); this.indexBlockText(e.replaceAll("_", " "), e), r.inputList.forEach((t => { t.fieldRow.forEach((t => { this.indexDropdownOption(t, e), this.indexBlockText(t.getText(), e) })) })) })) } indexDropdownOption(e, t) { e instanceof s.FieldDropdown && e.getOptions(!0).forEach((e => { "string" == typeof e[0] ? this.indexBlockText(e[0], t) : "alt" in e[0] && this.indexBlockText(e[0].alt, t) })) } blockTypesMatching(e) { return [...this.generateTrigrams(e).map((e => { var t; return null !== (t = this.trigramsToBlocks.get(e)) && void 0 !== t ? t : new Set })).reduce(((e, t) => this.getIntersection(e, t))).values()] } indexBlockText(e, t) { this.generateTrigrams(e).forEach((e => { var r; const s = null !== (r = this.trigramsToBlocks.get(e)) && void 0 !== r ? r : new Set; s.add(t), this.trigramsToBlocks.set(e, s) })) } generateTrigrams(e) { const t = e.toLowerCase(); if (!t) return []; if (t.length <= 3) return [t]; const r = []; for (let e = 0; e < t.length - 3; e++)r.push(t.substring(e, e + 3)); return r } getIntersection(e, t) { return new Set([...e].filter((e => t.has(e)))) } } class i extends s.ToolboxCategory { constructor(e, t, r) { super(e, t, r), this.blockSearcher = new o, this.initBlockSearcher(), this.registerShortcut() } createDom_() { var e; const t = super.createDom_(); return this.searchField = document.createElement("input"), this.searchField.type = "search", this.searchField.placeholder = "Search", this.workspace_.RTL ? this.searchField.style.marginRight = "8px" : this.searchField.style.marginLeft = "8px", this.searchField.addEventListener("keyup", (e => { if ("Escape" === e.key) return this.parentToolbox_.clearSelection(), !0; this.matchBlocks() })), null === (e = this.rowContents_) || void 0 === e || e.replaceChildren(this.searchField), t } getPosition() { var e; const t = (null === (e = this.workspace_.options.languageTree) || void 0 === e ? void 0 : e.contents) || []; for (let e = 0; e < t.length; e++)if (t[e].kind === i.SEARCH_CATEGORY_KIND) return e; return -1 } registerShortcut() { const e = s.ShortcutRegistry.registry.createSerializedKey(s.utils.KeyCodes.B, [s.utils.KeyCodes.CTRL]); s.ShortcutRegistry.registry.register({ name: i.START_SEARCH_SHORTCUT, callback: () => { const e = this.getPosition(); return !(e < 0 || (this.parentToolbox_.selectItemByPosition(e), 0)) }, keyCodes: [e] }) } getAvailableBlocks(e, t) { "contents" in e ? e.contents.forEach((e => { this.getAvailableBlocks(e, t) })) : "block" === e.kind.toLowerCase() && "type" in e && e.type && t.add(e.type) } initBlockSearcher() { var e, t; const r = new Set; null === (t = null === (e = this.workspace_.options.languageTree) || void 0 === e ? void 0 : e.contents) || void 0 === t || t.forEach((e => this.getAvailableBlocks(e, r))), this.blockSearcher.indexBlocks([...r]) } onClick(e) { super.onClick(e), e.preventDefault(), e.stopPropagation(), this.setSelected(this.parentToolbox_.getSelectedItem() === this) } setSelected(e) { super.setSelected(e), this.searchField && (e ? (this.searchField.focus(), this.matchBlocks()) : (this.searchField.value = "", this.searchField.blur())) } matchBlocks() { var e; const t = (null === (e = this.searchField) || void 0 === e ? void 0 : e.value) || ""; this.flyoutItems_ = t ? this.blockSearcher.blockTypesMatching(t).map((e => ({ kind: "block", type: e }))) : [], this.flyoutItems_.length || this.flyoutItems_.push({ kind: "label", text: t.length < 3 ? "Type to search for blocks" : "No matching blocks found" }), this.parentToolbox_.refreshSelection() } dispose() { super.dispose(), s.ShortcutRegistry.registry.unregister(i.START_SEARCH_SHORTCUT) } } return i.START_SEARCH_SHORTCUT = "startSearch", i.SEARCH_CATEGORY_KIND = "search", s.registry.register(s.registry.Type.TOOLBOX_ITEM, i.SEARCH_CATEGORY_KIND, i), {} })()));